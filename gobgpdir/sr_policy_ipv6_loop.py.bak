#!/usr/bin/env python

from __future__ import absolute_import
from __future__ import print_function

import grpc
from google.protobuf.any_pb2 import Any

import gobgp_pb2
import gobgp_pb2_grpc
import attribute_pb2

_TIMEOUT_SECONDS = 1000

#added by kun: ipv6 address pre-processing to fit in the script
def ipv6_to_intlist(ipv6):
    groups = ipv6.split(":")
    result = []
    for group in groups:
        group = int(group, 16)
        result.append(group)
    return result


#added by kun: label processing to carry ttl and s_flag information
def label_offset12(label):
    loop = 1
    while loop <= 12:
        label = label*2
        loop +=1
    return label

def label_update(labels):
    result = []
    label_num = len(labels)
    s_flag = 0
    loop = 0 # list index starts from 0
    while loop < label_num:
        label = labels[loop]

        if loop == (label_num-1):
            s_flag = 1

        label = label_offset12(label)+256*s_flag+255
        result.append(label)
        loop +=1
    return result



#original main funtion
def go_bgp_subnet(color, endpoint_device, target_device, sid_list, bsid_value, nh):
    """
    inject or delete an route with <ACME>-CIDR and <ACME>-SCRUBBING community
    NLRI
    ORIGIN
    AS_PATH
    LP
    EXTENDED COMMUNITIES
     RT
    TUNNEL ENCAP
     TLVs
      SR Policy
       SUB-TLVs
        Preference
        Binding-SID
        SEG-LIST
         WEIGHT
         SEGMENT(1..n)
    """
    channel = grpc.insecure_channel("localhost:50051")
    stub = gobgp_pb2_grpc.GobgpApiStub(channel)
    attributes = []
    segments = []
    # bgp-sr-te safi
    family = gobgp_pb2.Family(
        afi=gobgp_pb2.Family.AFI_IP6, safi=gobgp_pb2.Family.SAFI_SR_POLICY
    )

    # sr-te policy nlri
    nlri = Any()
    nlri.Pack(
        attribute_pb2.SRPolicyNLRI(
            color=color,
            distinguisher=666,
            endpoint=bytes(ipv6_to_intlist(endpoint_device)),
            length=192,
        )
    )

    # next-hop
    next_hop = Any()
    next_hop.Pack(
        attribute_pb2.NextHopAttribute(
            next_hop=nh,
        )
    )
    attributes.append(next_hop)

    # Origin
    origin = Any()
    origin.Pack(attribute_pb2.OriginAttribute(origin=0))
    attributes.append(origin)
    # Ext RT Communities
    rt = Any()
    rt.Pack(
        attribute_pb2.IPv4AddressSpecificExtended(
            address=target_device, local_admin=1, sub_type=0x02, is_transitive=False
        )
    )
    communities = Any()
    communities.Pack(
        attribute_pb2.ExtendedCommunitiesAttribute(
            communities=[rt],
        )
    )
    attributes.append(communities)
    # generic sid used for bsid
    sid = Any()
    sid.Pack(
        attribute_pb2.SRBindingSID(
            s_flag=False, i_flag=False, sid=(bsid_value).to_bytes(4, byteorder="big")
        )
    )
    # bsid
    bsid = Any()
    bsid.Pack(attribute_pb2.TunnelEncapSubTLVSRBindingSID(bsid=sid))

    # generic segment lbl
    sid_list = label_update(sid_list)

    for n in sid_list:
        segment = Any()
        segment.Pack(
            attribute_pb2.SegmentTypeA(
                flags=attribute_pb2.SegmentFlags(v_flag=False, a_flag=False, s_flag=False, b_flag=False), label=n
            )
        )
        segments.append(segment)
    # segment list
    seglist = Any()
    seglist.Pack(
        attribute_pb2.TunnelEncapSubTLVSRSegmentList(
            weight=attribute_pb2.SRWeight(flags=0, weight=12),
            segments=segments,
        )
    )

    # pref
    pref = Any()
    pref.Pack(attribute_pb2.TunnelEncapSubTLVSRPreference(flags=0, preference=11))

    # path name not used for now
    cpn = Any()
    cpn.Pack(
        attribute_pb2.TunnelEncapSubTLVSRCandidatePathName(
            candidate_path_name="test-path"
        )
    )
    # priority not used for now
    pri = Any()
    pri.Pack(attribute_pb2.TunnelEncapSubTLVSRPriority(priority=10))


    tun = Any()
    # generate tunnel
    tun.Pack(
        attribute_pb2.TunnelEncapAttribute(
            tlvs=[
                attribute_pb2.TunnelEncapTLV(
                    type=15,
                    tlvs=[
                        pref,
                        # bsid,
                        seglist,
                        # cpn,
                        # pri,
                    ],
                )
            ]
        )
    )

    attributes.append(tun)

    stub.AddPath(
        gobgp_pb2.AddPathRequest(
            table_type=gobgp_pb2.GLOBAL,
            path=gobgp_pb2.Path(
                nlri=nlri,
                pattrs=attributes,
                family=family,
                best=True,
            ),
        ),
        _TIMEOUT_SECONDS,
    )


if __name__ == "__main__":

    lsp_num = 2 #total lsp number
    
    #initiate
    current_lsp = 1 # current lsp no. start from the first one
    current_color = 100 # color value for the first lsp
    current_labels = [11000,12000] #label value for the first lsp
    
    #nh = input("please input the IP address of gobgp controller:")
    nh = "172.27.100.105"
    
    #target_device = input("please input the Router ID of DUT:")
    target_device = "1.1.1.1"
    
    #endpoint_device = input("please input the SR LSP endpoint:")
    endpoint_device = "20:02:02:02:00:00:00:00:00:00:00:00:00:00:00:01"
    
    bsid_value = 10000 #it could be any value, not used actually

    #loop
    while current_lsp <= lsp_num:
        #do work - print current lsp no.
        print("current_lsp is", current_lsp)
        print("current color is", current_color)
        print("current label is", current_labels)
        
        #do work - call function go_bgp_subnet
        go_bgp_subnet(
            color=current_color,
            endpoint_device=endpoint_device,
            target_device=target_device,
            bsid_value=bsid_value,
            sid_list=current_labels,
            nh=nh,
        )
        

        #goto next loop
        current_lsp +=1
        current_color +=1
        current_labels = [x+1 for x in current_labels]
